{
  "hash": "9d88bf197058c535f9bb147de5798fe6",
  "result": {
    "markdown": "---\ntitle: Gamma GLM\ninstitute: \"University of Padova\"\nauthor: \n  - name: \"Filippo Gambarota\"\n    email: filippo.gambarota@unipd.it\n    twitter: fgambarota\n    github: filippogambarota\nformat:\n  quarto-slides-revealjs:\n    incremental: false\n    code-link: true\n    code-line-numbers: false\n    html-math-method: mathjax\n    code-fold: true\n    filters:\n      - nutshell\n      - code-fullscreen\nfrom: markdown+emoji\ndate: last-modified\nfinal-slide: false\ndf-print: tibble\nbibliography: \"https://raw.githubusercontent.com/filippogambarota/bib-database/main/references.bib\"\ncsl: \"https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n# Understanding parameters {.section}\n\n## $\\mu$ and $\\sigma$ parametrization\n\n- Using the `gamma_params()` function we can think in terms of $\\mu$ and $\\sigma$ and generate the right parameters (e.g., *shape* and *rate*).\n- Let's simulate observations from a Gamma distribution with $\\mu = 500$ and $\\sigma = 200$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngm <- gamma_params(mean = 500, sd = 200)\ny <- rgamma(1e4, shape = gm$shape, scale = gm$scale)\nhist(y, breaks = 100, col = \"dodgerblue\")\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-2-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nThen we can fit an intercept-only model with the `Gamma` family and a `log` link function. You have to specify the link because the default is `inverse`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfam <- Gamma(link = \"log\")\ndat <- data.frame(y)\nfit0 <- glm(y ~ 1, family = fam, data = dat)\nsummary(fit0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> glm(formula = y ~ 1, family = fam, data = dat)\n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  6.21736    0.00399    1558   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.159225)\n#> \n#>     Null deviance: 1631.4  on 9999  degrees of freedom\n#> Residual deviance: 1631.4  on 9999  degrees of freedom\n#> AIC: 133239\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\n- $\\beta_0$ is the $\\mu$ of the Gamma distribution. We need to apply the inverse (`exp`) to get the original scale:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(mean = mean(dat$y), mean_true = gm$mean, b0 = exp(coef(fit0)[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>           mean      mean_true b0.(Intercept) \n#>       501.3775       500.0000       501.3775\n```\n:::\n:::\n\n\n- as always you can use the `fam()` object if you are not sure about the link functions as `fam$linkinv(coef(fit0)[1])`\n\n## $\\mu$ and $\\sigma$ parametrization\n\nNow let's simulate the difference between two groups. Again fixing the $\\mu_0 = 500$, $\\mu_1 = 600$ and a common $\\sigma = 200$. Let's plot the empirical densities:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggamma(mean = c(500, 600), sd = c(200, 200))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-5-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nUsing the `group` variable as dummy-coded, $\\beta_0 = \\mu_0$ and $\\beta_1 = \\mu_1 - \\mu_0$. Note that we are in the log scale.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nns <- 1e4\nm0 <- 500\nm1 <- 600\ns <- 200\n# parameters, log link\nb0 <- log(m0)\nb1 <- log(m1) - log(m0) # equivalent to log(m1 / m0)\nx <- rep(c(0, 1), each = ns/2)\nlp <- b0 + b1 * x # linear predictor\nmu <- exp(lp) # inverse exp link\ngm <- gamma_params(mean = mu, sd = s)\ny <- rgamma(ns, shape = gm$shape, scale = gm$scale)\ndat <- data.frame(y, x)\n```\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nLet's see the simulated data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nhist(dat$y, col = \"dodgerblue\", breaks = 100)\nboxplot(y ~ x, data = dat)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-7-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nNow we can fit the model and extract the parameters:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(y ~ x, data = dat, family = fam)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> glm(formula = y ~ x, family = fam, data = dat)\n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 6.211749   0.005222 1189.54   <2e-16 ***\n#> x           0.181834   0.007385   24.62   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.1363453)\n#> \n#>     Null deviance: 1473.0  on 9999  degrees of freedom\n#> Residual deviance: 1390.5  on 9998  degrees of freedom\n#> AIC: 133550\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\n- $\\beta0$ is the mean of the first group and $\\beta_1$ is the $\\log(\\mu_1/\\mu_0)$ or the difference $\\log(\\mu_1) - log(\\mu_0)$ \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmm <- tapply(dat$y, dat$x, mean)\ncoefs <- coef(fit)\n# manually\nc(mm[\"0\"], mm[\"1\"], diff = log(mm[\"1\"]) - log(mm[\"0\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>           0           1      diff.1 \n#> 498.5726278 597.9957728   0.1818344\n```\n:::\n\n```{.r .cell-code}\n# model\nc(exp(coefs[1]), exp(coefs[1] + coefs[2]), coefs[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> (Intercept) (Intercept)           x \n#> 498.5726278 597.9957728   0.1818344\n```\n:::\n:::\n\n\n## $\\mu$ and $\\sigma$ parametrization\n\nThe other estimated parameter is the **dispersion** that is defined as the inverse of the **shape**. We have not a single shape but the average is roughly similar to the true value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfits <- summary(fit)\nfits$dispersion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.1363453\n```\n:::\n\n```{.r .cell-code}\n1/mean(unique(gm$shape))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.1311475\n```\n:::\n:::\n\n\n<!-- TODO capire se è giusto, forse non è in linea con le assunzioni del modello questo -->\n\n## $\\mu$ and `shape` parametrization\n\n- This is common in `brms` and other packages^[See an example https://rpubs.com/jwesner/gamma_glm]. The $\\mu$ is the same as before and the `shape` ($\\alpha$) **determine the skewness of the distribution**. For the Gamma, the skewness is calculated as $\\frac{2}{\\sqrt{\\alpha}}$.\n- To generate data, we calculate the **scale** ($\\theta$) as $\\frac{\\mu}{\\alpha}$ (remember that $\\mu = \\alpha\\theta$)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- 50\nshape <- 10\ny <- rgamma(1e4, shape = shape, scale = mu/shape)\nhist(y, col = \"dodgerblue\", breaks = 100)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-11-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## $\\mu$ and `shape` parametrization\n\n- the expected skewness is `2/sqrt(shape)` 0.632 and is similar to the value computed on the simulated data\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\n2/sqrt(shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.6324555\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\npsych::skew(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.649647\n```\n:::\n:::\n\n\n- as $\\alpha$ increase, the Gamma distribution is less skewed and approaches a Gaussian distribution. When $\\mu = \\alpha$ the distribution already start to be pretty Gaussian\n\n## Skewness - $\\alpha$ relationship\n\nWe can plot the function that determine the skewness of the Gamma fixing $\\mu$ and varying $\\alpha$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncurve(2/sqrt(x), 0, 50, ylab = \"Skewness\", xlab = latex(\"\\\\alpha (shape)\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-13-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## Skewness - $\\alpha$ relationship\n\nCompared to the $\\mu$-$\\sigma$ method, here we fix the skewness and $\\mu$, thus the $\\hat \\sigma$ will differ when $\\mu$ change but the skewness is the same. The opposite is also true.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- c(50, 80)\n\n# mu-shape parametrization\ny1 <- rgamma(1e6, shape = 10, scale = mu[1]/10)\ny2 <- rgamma(1e6, shape = 10, scale = mu[2]/10)\n\n# mu-sigma parametrization\ngm <- gamma_params(mean = mu, sd = c(20, 20))\nx1 <- rgamma(1e6, shape = gm$shape[1], scale = gm$scale[1])\nx2 <- rgamma(1e6, shape = gm$shape[2], scale = gm$scale[2])\n\npar(mfrow = c(1,2))\n\nplot(density(y1), lwd = 2, main = latex(\"\\\\mu and \\\\alpha parametrization\"), xlab = \"x\", xlim = c(0, 250))\nlines(density(y2), col = \"firebrick\", lwd = 2)\nlegend(\"topright\", \n       legend = c(latex(\"\\\\mu = %s, \\\\alpha = %s, \\\\hat{\\\\sigma} = %.0f, sk = %.2f\", mu[1], 10, sd(y1), psych::skew(y1)),\n                  latex(\"\\\\mu = %s, \\\\alpha = %s, \\\\hat{\\\\sigma} = %.0f, sk = %.2f\", mu[2], 10, sd(y2), psych::skew(y1))),\n       fill = c(\"black\", \"firebrick\"))\n\nhatshape <- c(gamma_shape(x1, \"invskew\"), gamma_shape(x2, \"invskew\"))\n\nplot(density(x1), lwd = 2, main = latex(\"\\\\mu and \\\\sigma parametrization\"), xlab = \"x\", xlim = c(0, 250))\nlines(density(x2), col = \"firebrick\", lwd = 2)\nlegend(\"topright\", \n       legend = c(latex(\"\\\\mu = %s, \\\\sigma = %s, \\\\hat{\\\\alpha} = %.0f, sk = %.2f\", mu[1], 20, hatshape[1], psych::skew(x1)),\n                  latex(\"\\\\mu = %s, \\\\sigma = %s, \\\\hat{\\\\alpha} = %.0f, sk = %.2f\", mu[2], 20, hatshape[2], psych::skew(x2))),\n       fill = c(\"black\", \"firebrick\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-14-1.svg){fig-align='center' width=960}\n:::\n:::\n\n\n## Coefficient of variation\n\n<!-- TODO rivedi questa parte -->\n\nThe *coefficient of variation* $\\frac{\\sigma}{\\mu} = \\frac{1}{\\sqrt{\\alpha}}$ is constant under the $\\mu$-$\\alpha$ parametrization while can be different under the $\\mu$-$\\sigma$ one when $\\alpha$ or $\\sigma$ is fixed across conditions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# mu-shape\nc(cv(y1), cv(y2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.3160896 0.3159911\n```\n:::\n\n```{.r .cell-code}\n# mu-sigma\nc(cv(x1), cv(x2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.3993593 0.2499694\n```\n:::\n:::\n\n\nThe $\\alpha$ parameter allow to control the $CV$\n\n## $\\mu$ and $\\sigma$ relationship\n\nsee https://civil.colorado.edu/~balajir/CVEN6833/lectures/GammaGLM-01.pdf. The $\\sigma = \\frac{\\mu}{\\sqrt{\\alpha}}$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu <- 50\ncurve(50 / sqrt(x), 0, 100, xlab = latex(\"\\\\alpha\"), ylab = latex(\"\\\\mu/\\\\sqrt{\\\\alpha}\"))\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-16-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## Example: the Simon effect\n\n> The Simon effect is the difference in accuracy or reaction time between trials in which stimulus and response are on the same side and trials in which they are on opposite sides, with responses being generally slower and less accurate when the stimulus and response are on opposite sides.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Source: @van-den-Wildenberg2010-st](img/simon-task.jpg){fig-align='center' width=320}\n:::\n:::\n\n\n## Example: the Simon effect\n\nLet's import the `data/simon.rda` file^[Source: https://github.com/michael-franke/aida-package]. You can use the `load()` function or the `read_rda()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimon <- read_rda(here(\"data\", \"simon.rda\"))\nhead(simon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 6 × 15\n#>   submission_id    RT condition   correctness class    experiment_id key_pressed\n#>           <dbl> <dbl> <chr>       <chr>       <chr>            <dbl> <chr>      \n#> 1          7432  1239 incongruent correct     Intro C…            52 q          \n#> 2          7432   938 incongruent correct     Intro C…            52 q          \n#> 3          7432   744 incongruent correct     Intro C…            52 q          \n#> 4          7432   528 incongruent correct     Intro C…            52 q          \n#> 5          7432   706 incongruent correct     Intro C…            52 p          \n#> 6          7432   547 congruent   correct     Intro C…            52 p          \n#> # ℹ 8 more variables: p <chr>, pause <dbl>, q <chr>, target_object <chr>,\n#> #   target_position <chr>, timeSpent <dbl>, trial_number <dbl>,\n#> #   trial_type <chr>\n```\n:::\n:::\n\n\n## Example: the Simon effect\n\nFor simplicity, let's consider only a single subject (`submission_id`: 7432), otherwise the model require including random effects. We also exclude strange trials with RT > 2500 ms.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsimon <- filter(simon, \n                submission_id == 7432,\n                RT < 2500)\n```\n:::\n\n\n## Example: the Simon effect\n\nLet's plot the reaction times. Clearly the two distributions are right-skewed with a difference in location ($\\mu$). The shape also differs between thus also the skewness is probably different:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(simon, aes(x = RT, fill = condition)) +\n  geom_density(alpha = 0.7)\n```\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-20-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## Example: the Simon effect\n\nLet's see some summary statistics. We see the difference between the two conditions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nfuns <- list(mean = mean, sd = sd, skew = psych::skew, cv = cv)\nsumm <- tapply(simon$RT, simon$condition, function(x) sapply(funs, function(f) f(x)))\nsumm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $congruent\n#>        mean          sd        skew          cv \n#> 504.1818182  81.7038670   0.5328521   0.1620524 \n#> \n#> $incongruent\n#>        mean          sd        skew          cv \n#> 564.0312500 123.4188852   2.8702013   0.2188157\n```\n:::\n:::\n\n\n## Example: the Simon effect\n\nGiven that we modelling the difference in $\\mu$, this is the expected difference. We are working on the log scale, thus the model is estimating the `log` difference or the `log` ratio.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nsumm$incongruent[\"mean\"] - summ$congruent[\"mean\"]\n#>     mean \n#> 59.84943\nlog(summ$incongruent[\"mean\"]) - log(summ$congruent[\"mean\"])\n#>      mean \n#> 0.1121727\nlog(summ$incongruent[\"mean\"] / summ$congruent[\"mean\"])\n#>      mean \n#> 0.1121727\n```\n:::\n\n\n## Example: the Simon effect\n\nLet's fit the model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nfit <- glm(RT ~ condition, data = simon, family = Gamma(link = \"log\"))\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> Call:\n#> glm(formula = RT ~ condition, family = Gamma(link = \"log\"), data = simon)\n#> \n#> Coefficients:\n#>                      Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)           6.22294    0.02625 237.053  < 2e-16 ***\n#> conditionincongruent  0.11217    0.03580   3.134  0.00218 ** \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for Gamma family taken to be 0.03790215)\n#> \n#>     Null deviance: 4.1148  on 118  degrees of freedom\n#> Residual deviance: 3.7439  on 117  degrees of freedom\n#> AIC: 1424.4\n#> \n#> Number of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\n## Example: the Simon effect\n\nPlotting the results:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nplot(ggeffect(fit))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> $condition\n```\n:::\n\n::: {.cell-output-display}\n![](04-gamma-glm_files/figure-revealjs/unnamed-chunk-24-1.svg){fig-align='center' width=576}\n:::\n:::\n\n\n## Example: the Simon effect\n\nThe main parameter of interest here is the $\\beta_1$ representing the difference in $\\mu$. We can interpret $\\exp(\\beta_1) = 1.119$ as the multiplicative increase in RT when moving from congruent to incongruent condition. In the RT scale, we have a difference of 59.8494318. Remember that the statistical test is performed on the link-function scale.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nemmeans(fit, pairwise ~ condition)$contrast\n#>  contrast                estimate     SE  df t.ratio p.value\n#>  congruent - incongruent   -0.112 0.0358 117  -3.134  0.0022\n#> \n#> Results are given on the log (not the response) scale.\nemmeans(fit, pairwise ~ condition, type = \"response\")$contrast\n#>  contrast                ratio    SE  df null t.ratio p.value\n#>  congruent / incongruent 0.894 0.032 117    1  -3.134  0.0022\n#> \n#> Tests are performed on the log scale\n```\n:::\n\n\n\n## References\n",
    "supporting": [
      "04-gamma-glm_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}