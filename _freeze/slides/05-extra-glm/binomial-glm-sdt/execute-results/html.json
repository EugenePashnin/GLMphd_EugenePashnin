{
  "hash": "b4bec94a03d55522aa462bbf7cdac387",
  "result": {
    "markdown": "---\ntitle: Signal Detection Theory and GLM\ninstitute: \"\\\\@event | Place\"\nauthor: \n  - name: \"Filippo Gambarota\"\n    email: filippo.gambarota@unipd.it\n    github: filippogambarota\nformat: \n  quarto-slides-revealjs:\n    slide-number: true\n    incremental: false\n    code-link: true\n    code-line-numbers: false\n    html-math-method: mathjax\n    margin: 0\n    filters:\n      - nutshell\n      - code-fullscreen\nfrom: markdown+emoji\ndate: last-modified\nfinal-slide: true\ndf-print: default\nbibliography: \"https://raw.githubusercontent.com/filippogambarota/bib-database/main/references.bib\"\ncsl: \"https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\"\ntoc: true\ntoc-title: Contents\ntoc-depth: 1\nengine: knitr\n---\n\n\n\n\n\n\n\n\n\n\n# Signal Detection Theory {.section}\n\n## Signal Detection Theory (SDT)\n\n- The SDT is a statistical approach to evaluate the ability of subject to **discriminate between signal and noise**.\n- Can be used for perceptual decisions, psychophysics, eyewitnesses, diagnostic tools\n- Whatever we have a binary decision for a *noisy* stimulus we can model the decision making using SDT\n\n## SDT diagnostic example\n\nWe have $n = 100$ subjects where $50%$ have a certain condition and the rest are healthy. We want to test the ability of a clinician to detect the condition based on available information.\n\nWe summarise information using the variable `x` where patients are supposed to be higher compared to healthy people.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggnorm(c(0, 1), c(1,1))\n```\n\n::: {.cell-output-display}\n![](binomial-glm-sdt_files/figure-revealjs/unnamed-chunk-5-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## SDT diagnostic example\n\nThe distance between the distributions is the actual difference between people. The clinician need to (internally) decide where to put the vertical line to classify people.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggnorm(c(0, 1), c(1,1)) +\n  geom_vline(xintercept = c(-1, 0, 2), lty = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](binomial-glm-sdt_files/figure-revealjs/unnamed-chunk-6-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## SDT diagnostic example\n\nWhen we collect data, we are not observing the `x` variable but the binary decision. The signal detection theory estimate the actual distance between latent distributions AND the decision threshold.\n\n- The distance between distributions is called d$'$ (dprime)\n- The decision threshold is called criterion\n\n## SDT diagnostic example\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-sdt_files/figure-revealjs/unnamed-chunk-7-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n\n## SDT diagnostic example\n\nLet's see some data:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n#>   say_signal is_signal      x\n#> 1          0         0 -2.633\n#> 2          1         1  1.495\n#> 3          1         0  1.998\n#> 4          1         1  2.584\n#> 5        ...       ...    ...\n#> 6          1         0   0.86\n#> 7          0         1 -0.305\n#> 8          0         0 -2.278\n#> 9          1         1  1.634\n```\n:::\n:::\n\n\nWe have the `x` because these are simulated data but in real-world SDT we know the actual state `is_signal` and the response `say_signal`.\n\n## SDT diagnostic example\n\nGiven that we know the truth (`is_signal`), we can tabulate the participant clinician responses:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nxtabs(~say_signal + is_signal, data = dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>           is_signal\n#> say_signal  1  0\n#>          1 16  9\n#>          0  9 16\n```\n:::\n:::\n\n\nWithin this table:\n\n- `11` are called **HITS**\n- `10` are called **MISS**\n- `01` are called **FALSE ALARMS** (FA)\n- `00` are called **CORRECT REJECTIONS** (CR)\n\n## SDT diagnostic example\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table style=\"border-collapse:collapse; border:none;\">\n <tr>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal; border-bottom:1px solid;\" rowspan=\"2\">is_signal</th>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal;\" colspan=\"2\">say_signal</th>\n <th style=\"border-top:double; text-align:center; font-style:italic; font-weight:normal; font-weight:bolder; font-style:italic; border-bottom:1px solid; \" rowspan=\"2\">Total</th>\n </tr>\n \n<tr>\n <td style=\"border-bottom:1px solid; text-align:center; padding:0.2cm;\">1</td>\n <td style=\"border-bottom:1px solid; text-align:center; padding:0.2cm;\">0</td>\n </tr>\n \n<tr> \n<td style=\"padding:0.2cm;  text-align:left; vertical-align:middle;\">1</td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">16</span><br><span style=\"color:#993333;\">32&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">9</span><br><span style=\"color:#993333;\">18&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;  \"><span style=\"color:black;\">25</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td> \n</tr>\n \n<tr> \n<td style=\"padding:0.2cm;  text-align:left; vertical-align:middle;\">0</td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">9</span><br><span style=\"color:#993333;\">18&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center; \"><span style=\"color:black;\">16</span><br><span style=\"color:#993333;\">32&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;  \"><span style=\"color:black;\">25</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td> \n</tr>\n \n<tr> \n<td style=\"padding:0.2cm;  border-bottom:double; font-weight:bolder; font-style:italic; text-align:left; vertical-align:middle;\">Total</td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">25</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">25</span><br><span style=\"color:#993333;\">50&nbsp;&#37;</span></td>\n<td style=\"padding:0.2cm; text-align:center;   border-bottom:double;\"><span style=\"color:black;\">50</span><br><span style=\"color:#993333;\">100&nbsp;&#37;</span></td> \n</tr>\n \n</table>\n`````\n:::\n:::\n\n\n## SDT diagnostic example\n\nThe main assumption of the (equal-variance) SDT is that signal and noise are normally distributed (at the latent level). Thus:\n\n$$\nd' = \\Phi(pHIT) - \\Phi(pFA)\n$$\n\n$$\nc = \\frac{\\Phi(pHIT) + \\Phi(pFA)}{2}\n$$\n\nTo note, the criterion $c$ has different formulation while the equation above is the most common.\n\n## SDT diagnostic example\n\nWe can use the `sdt` function to calculate the frequency and proportions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsdt_res <- sdt(dat$is_signal, dat$say_signal)\ndata.frame(sdt_res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   hit miss fa cr phit  pfa  c\n#> 1  16    9  9 16 0.64 0.36 NA\n```\n:::\n:::\n\n\nAnd the `psycho::dprime()` function to calculate the parameters:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npsycho::dprime(sdt_res$hit, sdt_res$fa, sdt_res$miss, sdt_res$cr)[c(\"dprime\", \"c\")] |> \n  data.frame()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>      dprime            c\n#> 1 0.6882049 8.326673e-17\n```\n:::\n:::\n\n\n## SDT diagnostic example\n\nThe d$'$ is interpreted as the ability of the clinician to discriminate between healthy people and patients. The criterion is the tendency to say healthy or disease more frequently.\n\n- **Conservative Criterion**: tendency to say no (positive $c$)\n- **Liberal Criterion**: tendency to say yes (negative $c$)\n\nWhatever the criterion, the best classification is associated with having an unbiased criterion. The perfect classification depends on the true d$'$. In a noisy decision (non complete separation between signal and noise), there is no strategy to achieve $pHIT = 1$ and $pFA = 0$.\n\n## SDT diagnostic example\n\nAssuming we are able to have access to `x`, we could try different $c$ to see which is the actual impact:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-sdt_files/figure-revealjs/unnamed-chunk-13-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n## SDT diagnostic example\n\nThe standard binary accuracy within the SDT framework is just $(HIT + CR) / (HIT + CR + FA + MISS)$. Again the accuracy is maximized when the criterion is unbiased. In other terms, saying always \"healthy\" or \"disease\" is penalized.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](binomial-glm-sdt_files/figure-revealjs/unnamed-chunk-14-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\n# Binomial GLM - Probit link and SDT {.section}\n\n## Binomial GLM - Probit link and SDT\n\nSDT parameters can easily be estimated within GLM framework [@DeCarlo1998-ay]. The `say_signal ~ is_signal` relationship is just a Binomial GLM with a probit (instead of the logit) link function.\n\n## Binomial GLM - Probit link and SDT\n\nWe could manually calculate the d$'$ and criterion (instead of using the `psycho::dprime()` function) to better understand the process:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# dprime\nqnorm(sdt_res$phit) - qnorm(sdt_res$pfa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.7169176\n```\n:::\n\n```{.r .cell-code}\n# criterion, negative = tendency to say yes\n-((qnorm(sdt_res$phit) + qnorm(sdt_res$pfa))/2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0\n```\n:::\n:::\n\n\n## Binomial GLM - Probit link and SDT\n\nThen we can fit GLM with a **probit** link predicting the response:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(say_signal ~ is_signal, \n           contrasts = list(is_signal = -contr.sum(2)/2),\n           data = dat, \n           family = binomial(link = \"probit\"))\n\n# the intercept is the criterion\n-coef(fit)[1] # flipping the sign is required for the different parametrization\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>   (Intercept) \n#> -4.028916e-17\n```\n:::\n\n```{.r .cell-code}\n# the slipe is the dprime\ncoef(fit)[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> is_signal1 \n#>  0.7169176\n```\n:::\n:::\n\n\n## Binomial GLM - Probit link and SDT\n\nWhy? \n\nAssuming a logit link, the $\\beta_0$ is the logit transformation of the probability of the reference level. Here we are using `-0.5, 0.5` coding thus the logit transformation of the midpoint between signal and noise. This is the same as doing $c = \\frac{\\Phi(pHIT) + \\Phi(pFA)}{2}$.\n\n$\\beta_1$ would be the log odds ratio between signal and noise. In this case is the difference between the two latent distributions assuming normality.\n\n## References {.refs}\n\n::: {#refs}\n:::\n",
    "supporting": [
      "binomial-glm-sdt_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}